

#define release
 

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;



namespace Prism_to_OpenDDS
{
    class Program 
    {
        static void Main(string[] args)
        {

            if (args.Length < 2)
            {
                System.Console.WriteLine("Usage: prism_to_opendds Inputfile.idl Outputfile.idl");
                return;
            }
            //get filename to parse from params
            string inDirName = args[0];
            if (!Directory.Exists(inDirName))
            {
                System.Console.WriteLine("Directory does not exist{0}\n", inDirName);
                return;
            }

            foreach (String infile in Directory.EnumerateFiles(inDirName, "*.idl", SearchOption.AllDirectories))
            {
                //Get file name
                string inFileName = Path.GetFileNameWithoutExtension(infile);
                string outFileName = $"{args[1]}\\{inFileName}.idl";

                //get files ready
                TextReader inFile = new StreamReader(infile);
                TextWriter outFile = new StreamWriter(outFileName);
                outFile.WriteLine(
                    "////////////////////////////////////////////////////////\n" +
                    "//    This OpenDDS IDL file has been autogenerated    //\n" +
                    "////////////////////////////////////////////////////////\n\n");

                //Read input file by line until eof
                string line = "";
                string module = "";
                string structName = "";
                string structLines = "";
                string openDDS = "";
                int sequence = 1;
                string typeDefs = "";
                Dictionary<string, string> typedefDict = new Dictionary<string, string>();////////// Typedefs created to replace sequences - OpenDDS IDL compiler files when using anonymous types\n";
                bool inStruct = false;

                while ((line = inFile.ReadLine()) != null)
                {

                    //if a #pragma keylist found convert to Open DDS
                    if (line.Trim().StartsWith("#pragma keylist"))
                    {
                        string[] sublines = line.Substring(line.IndexOf("keylist") + 8).Split(new Char[] { ' ' });
                        if (sublines.Length < 2)
                        {
                            Console.WriteLine("Error parsing #pragma - didn't get any elements");
                            break;
                        }
                        //sanity check
                        if (!sublines[0].Trim().Equals(structName))
                        {
                            Console.WriteLine("#pragma structure name doesn't match the preceeding struct name - expecting {0}, got {1}", structName, sublines[0]);
                            break;
                        }
                        openDDS = "//OpenDDS directives \n#pragma DCPS_DATA_TYPE \"" + module + "::" + structName + "\"\n";

                        for (int i = 1; i < sublines.Length; i++)
                        {
                            openDDS += "#pragma DCPS_DATA_KEY \"" + module + "::" + structName + " " + sublines[i] + "\"\n";
                        }
                        outFile.WriteLine(typeDefs);
                        outFile.WriteLine(openDDS);
                        outFile.WriteLine(structLines);
                        outFile.WriteLine("//Original Prism #pragma\n//" + line);
                        structLines = "";
                        typeDefs = "";
                        continue;
                    }
                    //read each struct - in OpenDDS the #pargmas go before the structs, but Prism has them after.
                    if (line.Trim().StartsWith("struct"))
                    {
                        if (structLines.Length > 0)// print captured structs with no pragmas
                        {
                            outFile.WriteLine(structLines);
                            structLines = "";
                        }

                        inStruct = true;
                        structName = line.Substring(line.IndexOf("struct") + 7).Trim();
                        Console.WriteLine("In Structure: {0}", structName);
                    }
                    if (line.Trim().StartsWith("sequence")) //OpenDDS does not allow sequences in structs - need to typedef them before hand
                    {
                        string key = line.Substring(0, line.IndexOf(">") + 1).Trim();
                        string remainder = line.Substring(line.IndexOf("> ") + 1).Trim();

                        string newLine = "";
                        if (!typedefDict.ContainsKey(key))
                        {
                            string seq = String.Format("T_Sequence_{0:000}", sequence++);
                            typedefDict.Add(key, seq);
                            typeDefs += "\n//Autogenerated typedef to replace anonymous type - deprecated in OpenDDS\ntypedef " + key + " " + seq + ";";
                        }
                        typedefDict.TryGetValue(key, out newLine);
                        int indent = line.TakeWhile(c => c == ' ').Count();
                        line = new string(' ', indent) + newLine + " " + remainder;
                    }
                    if (inStruct)
                    {
                        structLines += line + "\n";
                        if (line.Trim().StartsWith("};"))
                        {
                            inStruct = false;
                        }
                        continue;
                    }
                    //reset module name if found
                    if (line.Trim().StartsWith("module"))
                    {
                        module = line.Substring(line.IndexOf("module") + 7).Trim();
                        Console.WriteLine("In Module: {0}", module);
                    }
                    //otherwise wite each line to output file                
                    outFile.WriteLine(line);
                }
                Console.WriteLine("Finished parsing.");
                inFile.Close();
                outFile.Close();
            }
        }
    }
}
